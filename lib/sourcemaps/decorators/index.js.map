{"version":3,"sources":["decorators/index.ts"],"names":[],"mappings":";;AAAA,2DAAuF;AAyCvF;;;;;GAKG;AACU,QAAA,UAAU,GAA6C,kCAAa,CAAC,YAAY,EAAE,EAAE,CAAC,CAAC;AAmBpG;;;;;GAKG;AACU,QAAA,UAAU,GAA6C,kCAAa,CAAC,YAAY,EAAE,EAAE,CAAC,CAAC;AAkEpG;;;;;GAKG;AACU,QAAA,KAAK,GAAmB,sCAAiB,CAAC,OAAO,EAAE,CAAC,CAAC,qBAAqB,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC;AA2DtG;;;;;GAKG;AACU,QAAA,MAAM,GAAoB,sCAAiB,CAAC,QAAQ,EAAE,CAAC,CAAC,qBAAqB,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC","file":"../../decorators/index.js","sourcesContent":["import { TypeDecorator, makeDecorator, makePropDecorator } from './decoratorFactories';\r\n\r\n/**\r\n * Type of the Injectable decorator / constructor function.\r\n *\r\n * @stable\r\n */\r\nexport interface InjectableDecorator {\r\n    /**\r\n     * @whatItDoes A marker metadata that marks a class as available to {@link Injector} for creation.\r\n     * @howToUse\r\n     * ```\r\n     * @Injectable()\r\n     * class Car {}\r\n     * ```\r\n     *\r\n     * @description\r\n     * For more details, see the {@linkDocs guide/dependency-injection \"Dependency Injection Guide\"}.\r\n     *\r\n     * ### Example\r\n     *\r\n     * {@example core/di/ts/metadata_spec.ts region='Injectable'}\r\n     *\r\n     * {@link Injector} will throw {@link NoAnnotationError} when trying to instantiate a class that\r\n     * does not have `@Injectable` marker, as shown in the example below.\r\n     *\r\n     * {@example core/di/ts/metadata_spec.ts region='InjectableThrows'}\r\n     *\r\n     * @stable\r\n     */\r\n    (): any;\r\n    new (): Injectable;\r\n}\r\n\r\n/**\r\n * Type of the Injectable metadata.\r\n *\r\n * @stable\r\n */\r\nexport interface Injectable { }\r\n\r\n/**\r\n * Injectable decorator and metadata.\r\n *\r\n * @stable\r\n * @Annotation\r\n */\r\nexport const Injectable: InjectableDecorator = <InjectableDecorator>makeDecorator('Injectable', []);\r\n\r\n\r\n/**\r\n * Type of the Controller decorator / constructor function.\r\n *\r\n * @stable\r\n */\r\nexport interface ControllerDecorator extends InjectableDecorator {\r\n    routePrefix?: string;\r\n}\r\n\r\n/**\r\n * Type of the Controller metadata.\r\n *\r\n * @stable\r\n */\r\nexport interface Controller { }\r\n\r\n/**\r\n * Controller decorator and metadata.\r\n *\r\n * @stable\r\n * @Annotation\r\n */\r\nexport const Controller: ControllerDecorator = <ControllerDecorator>makeDecorator('Controller', []);\r\n\r\n\r\n\r\n/**\r\n * Type of the Input decorator / constructor function.\r\n *\r\n * @stable\r\n */\r\nexport interface InputDecorator {\r\n    /**\r\n     * Declares a data-bound input property.\r\n     *\r\n     * Angular automatically updates data-bound properties during change detection.\r\n     *\r\n     * `Input` takes an optional parameter that specifies the name\r\n     * used when instantiating a component in the template. When not provided,\r\n     * the name of the decorated property is used.\r\n     *\r\n     * ### Example\r\n     *\r\n     * The following example creates a component with two input properties.\r\n     *\r\n     * ```typescript\r\n     * @Component({\r\n     *   selector: 'bank-account',\r\n     *   template: `\r\n     *     Bank Name: {{bankName}}\r\n     *     Account Id: {{id}}\r\n     *   `\r\n     * })\r\n     * class BankAccount {\r\n     *   @Input() bankName: string;\r\n     *   @Input('account-id') id: string;\r\n     *\r\n     *   // this property is not bound, and won't be automatically updated by Angular\r\n     *   normalizedBankName: string;\r\n     * }\r\n     *\r\n     * @Component({\r\n     *   selector: 'app',\r\n     *   template: `\r\n     *     <bank-account bank-name=\"RBC\" account-id=\"4747\"></bank-account>\r\n     *   `\r\n     * })\r\n     *\r\n     * class App {}\r\n     * ```\r\n     * @stable\r\n     */\r\n    (bindingPropertyName?: string): any;\r\n    new (bindingPropertyName?: string): any;\r\n}\r\n\r\n/**\r\n * Type of the Input metadata.\r\n *\r\n * @stable\r\n */\r\nexport interface Input {\r\n    /**\r\n     * Name used when instantiating a component in the template.\r\n     */\r\n    bindingPropertyName?: string;\r\n}\r\n\r\n/**\r\n * Input decorator and metadata.\r\n *\r\n * @stable\r\n * @Annotation\r\n */\r\nexport const Input: InputDecorator = makePropDecorator('Input', [['bindingPropertyName', undefined]]);\r\n\r\n/**\r\n * Type of the Output decorator / constructor function.\r\n *\r\n * @stable\r\n */\r\nexport interface OutputDecorator {\r\n    /**\r\n     * Declares an event-bound output property.\r\n     *\r\n     * When an output property emits an event, an event handler attached to that event\r\n     * the template is invoked.\r\n     *\r\n     * `Output` takes an optional parameter that specifies the name\r\n     * used when instantiating a component in the template. When not provided,\r\n     * the name of the decorated property is used.\r\n     *\r\n     * ### Example\r\n     *\r\n     * ```typescript\r\n     * @Directive({\r\n     *   selector: 'interval-dir',\r\n     * })\r\n     * class IntervalDir {\r\n     *   @Output() everySecond = new EventEmitter();\r\n     *   @Output('everyFiveSeconds') five5Secs = new EventEmitter();\r\n     *\r\n     *   constructor() {\r\n     *     setInterval(() => this.everySecond.emit(\"event\"), 1000);\r\n     *     setInterval(() => this.five5Secs.emit(\"event\"), 5000);\r\n     *   }\r\n     * }\r\n     *\r\n     * @Component({\r\n     *   selector: 'app',\r\n     *   template: `\r\n     *     <interval-dir (everySecond)=\"everySecond()\" (everyFiveSeconds)=\"everyFiveSeconds()\">\r\n     *     </interval-dir>\r\n     *   `\r\n     * })\r\n     * class App {\r\n     *   everySecond() { console.log('second'); }\r\n     *   everyFiveSeconds() { console.log('five seconds'); }\r\n     * }\r\n     * ```\r\n     * @stable\r\n     */\r\n    (bindingPropertyName?: string): any;\r\n    new (bindingPropertyName?: string): any;\r\n}\r\n\r\n/**\r\n * Type of the Output metadata.\r\n *\r\n * @stable\r\n */\r\nexport interface Output { bindingPropertyName?: string; }\r\n\r\n/**\r\n * Output decorator and metadata.\r\n *\r\n * @stable\r\n * @Annotation\r\n */\r\nexport const Output: OutputDecorator = makePropDecorator('Output', [['bindingPropertyName', undefined]]);"]}